## 1. 알고리즘
어떠한 문제를 해결하기 위한 여러 동작들의 모임이다. 유한성을 가지며, 언젠가는 끝나야 하는 속성을 가지고 있다.   수학과 컴퓨터 과학에서 알고리즘이란 작동이 일어나게 하는 내재하는 단계적 집합이다. 알고리즘은 연산, 데이터 진행 또는 자동화된 추론을 수행한다.  

### 알고리즘 조건
알고리즘은 다음의 조건을 만족해야 한다.  

- 입력 : 외부에서 제공되는 자료가 0개 이상 존재한다.  
- 출력 : 적어도 2개 이상의 서로 다른 결과를 내어야 한다.(즉 모든 입력에 하나의 출력이 나오면 안됨)  
- 명확성 : 수행 과정은 명확하고 모호하지 않은 명령어로 구성되어야 한다.  
- 유한성(종결성) : 유한 번의 명령어를 수행 후(유한 시간 내)에 종료한다.  
- 효율성 : 모든 과정은 명백하게 실행 가능(검증 가능)한 것이어야 한다.  

### 연구 분야
- 고안 : 완벽한 자동화를 통한 알고리즘의 개발은 거의 불가능하다. 따라서 이미 증명된 유용한 알고리즘들을 습득함으로써 보다 유용한 알고리즘을 개발하는데 그 의미가 있다.  
- 검증 : 고안된 알고리즘이 합당한 입력값에 대하여 올바른 결과를 계산해 내는지를 밝히는 절차가 필요하다. 알고리즘 검증은 고안된 알고리즘이 프로그래밍 언어와는 독립적으로 올바르게 작동할 수 있음을 보여주는 데 그 목적이 있다.  
- 분석 : 고안된 알고리즘을 실행하기 위해 필요한 실행시간과 필요로 하는 기억장치를 결정하는 것이다.  
- 테스트 : 디버깅, 성능분석  

### 좋은 알고리즘의 분석 기준
- 정확성 : 적당한 입력에 대해서 유한 시간내에 올바른 답을 산출하는가를 판단.
- 작업량 : 전체 알고리즘에서 수행되는 가장 중요한 연산들만으로 작업량을 측정. 해결하고자 하는 문제의 중요 연산이 여러개인 경우에는 각각의 중요 연산들의 합으로 간주하거나 중요 연산들에 가중치를 두어 계산
- 기억 장소 사용량 : 수행에 필요한 저장 공간
- 최적성 : 그 알고리즘보다 더 적은 연산을 수행하는 알고리즘은 없는가? 최적이란 가장 '잘 알려진' 이 아니라 '가장 좋은'의 의미이다
- 복잡도. (점근 표기법 : Big-O Notation)  
<br>

## 2. 오일러 순환과 해밀턴 순환

### 그래프
- 그래프는 정점(Vertex)의 집합과 선(Edge)들의 집합으로 구성되며 G = {V, E}로 표시한다
- 차수(degree)
    - 정점(u)에 접합된 연결선(Edge)의 수
    - deg(u)와 같이 표기하기도 한다
    - 자기 자신을 연결하는 연결선(loop)의 경우 차수를 2로 본다

### 오일러 순환
- 오일러 경로
    - 그래프 G의 모든 **연결선(Edge)** 를 한번만 방문하는 경로
    - 2개 이상의 정점을 갖는 루프가 없는 연결 그래프에서 홀수 차수를 갖는 정점이 **하나도 없거나 오직 2개** (시작점, 끝점)만 존재해야 한다  
- 오일러 순환
    - 시작점과 끝점이 동일한 오일러 경로
    - 오일러 경로에서 모든 정점이 **짝수** 차수를 가지면 오일러 순환이 존재한다
- 오일러 그래프
    - 오일러 순환이 존재하는 그래프
- 각 정점의 차수를 이용해 오일러 순환을 구할경우 시간복잡도
    - n 차수 ≤ n(n-1) ≤ n^2
    - O(n^2) O(n*m) (이때 m<n, m은 평균차수)

### 해밀턴 순환
- 밀턴 경로
    - 그래프 G에서 모든 **정점(Vertex)** 을 정확히 한번만 지나는 경로
- 해밀턴 순환
    - 시작점과 끝점이 같은 해밀턴 경로
- 해밀턴 순환을 찾는 알고리즘은 존재하지 않는다
    - 브루트포스 해야함
    - O(x^n) (x는 간선의 갯수, n은 정점의 수)
    - np Problem
- TSP(traveling salesman problem, 방문 판매원 문제)
    - 연결선에는 비용이 주어진다
    - 일반적으로 완전 그래프 탐색
    - 이 그래프에서 비용이 최소가 되는 해밀톤 순환을 찾는문제
    - n ≤ 11 경우: 브루트포스(O(n!))
    - n ≤ 12 경우: 백트래킹
    - n ≤ 16 경우: DP + BitMasking(2^n*n^2)  
<br>


## 3. 최소신장 트리

### 신장 트리(Spanngin Tree)

<img src="https://velog.velcdn.com/images/suk13574/post/798355fe-79bb-47c1-a1a7-f147ab31637b/image.png" alt="신장 트리" width="400" />  

- 위의 그림 그래프에서 아래 그래프 3개 모두 신장 트리(3개 말고 더 있을 수 있음)
- 그래프의 모든 정점을 포함하는 트리
- 그래프의 최소 연결 부분 그래프로 사이클이 없음
- 정점의 개수 n개면 간선의 개수 n-1개 가짐
- 하나의 그래프에 많은 신장 트리 존재

### 최소 신장 트리(MST, Minimum Spanning Tree)

<img src="https://velog.velcdn.com/images/suk13574/post/7a9af756-0ab1-457a-82ec-16556318b75b/image.png" alt="최소 신장 트리" width="400" />  

- 가운데 신장 트리는 신장 트리 중 가중치 합이 가장 최소인 최소 신장 트리
- 신장 트리 중 간선의 가중치 합이 최소인 트리
- 예제)
    - 도시마다 도로를 짓는데 최소 거리가 되도록 구축
    - 집마다 전화망 설치하는데 최소 비용이 되도록 설계  
<br>


## 4. 최단경로 알고리즘

### 크루스칼 알고리즘(Kruskal’s Algorithm)
그래프의 간선을 하나씩 늘리며 MST를 만든다. 간선을 늘릴 때 가중치가 최소인 간선부터 추가하는 탐욕법을 이용한다.

#### 과정
1) 간선은 가중치를 기준으로 오름차순 정렬한다.  
2) 간선을 하나씩 살핀다. 간선을 MST에 추가했을 때 MST에 사이클이 생기지 않으면 추가한다. 사이클이 생긴다면 다음 간선으로 넘어간다.  


### 프림 알고리즘(Prim’s Algorithm)
그래프의 정점 하나씩 늘리며 MST를 만든다. 정점을 늘릴 때 정점과 연결된 간선의 가중치가 최소인 것부터 추가하는 탐욕법을 이용한다.

#### 과정
1) 시작 정점을 고른다. 시작 정점을 MST에 추가한다.
2) 정점과 이어진 간선을 살핀다. 간선과 이어진 다음 정점이 MST에 있지 않다면 이 정점과 간선을 최소 힙에 추가한다.
3) 최소 힙에서 꺼낸 정점이 MST에 포함되어 있지 않다면 MST에 추가하고 2)를 진행한다. 만약 꺼낸 정점이 MST에 포함되어 있으면 넘어간다.
4) 최소 힙이 빌 때까지 3)을 반복한다.
